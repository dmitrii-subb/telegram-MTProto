# Telegram MTProto
### (English)
This project is an attempt to implement the MTProto encryption protocol in chats in local network. This product is adapted only for operating systems of the family Linux.

### (Русский)
Этот семестровый проект - реализация протокола шифрования MTProto в чате локальной сети. Программа написана под linux.
## Описание программной реализации MTProto

Работа с потоками осуществляется при помощи класса std::thread. Работа с большими числами осуществляется при помощи библиотеки gmp. 
Также при помощи gmp реализован протокол Диффи-Хеллмана (модуль keyExchange.cpp) и функция getDigit (модуль digits.cpp).
Работа с шифрованием осуществляется при помощи библиотеки cryptopp.

При помощи cryptopp реализованы такие алгоритмы, как:
- RAW-RSA (модуль rsa.cpp) 
- AES256 (модуль aes.cpp) 
- Base64Encoder (модуль aes.cpp) 
- Base64Decoder (модуль aes.cpp) 
- SHA256 (модуль sha256.cpp) 
Кодировка base64 используется только в модуле aes


## Модуль server.cpp
### Функция  main

Функция реализует работу с сокетами, инициализацию базы данных, создание нового потока.
Инициализация базы данных: создается база данных, содержащая таблицу:

Таблица 1 - структура базы данных сервера.
| SOCK_ID	| CHAR(64)	| NOT NULL |
|----------------|:---------:|----------------:|
| SESSION_ID |	CHAR(64)	| NOT NULL |
| AUTH_KEY	| CHAR(2048)	| NOT NULL |

Где sock_id - постоянный id клиента (дескриптор файла для сокета используется как id клиента на текущую сессию),
session_id – id, необходимый для работы протокола mtproto,
 
auth_key - уникальный ключ, использующийся для работы протокола mtproto.

### Функция  sendMsg

Реализует протокол mtproto на стороне сервера. Принимает два параметра - массив sockets (содержащий sock_id всех клиентов) и sock_id отправителя. В рамках этой функции sockets выступает в качестве массива с sock_id получателей.
Клиент и сервер обмениваются структурой package, в которой объявлены поля:
- sender_session_id - сессионный идентификатор клиента-отправителя, генерируется в ходе раунда обмена ключей (модуль keyExhange )
- recipient_session_id - сессионный идентификатор клиента-получателя (не используется)
- msg_len - длина сообщения
- msg_key - уникальный идентификатор сообщения
- encrypted_data - зашифрованная информация AES256(salt+session_id+msg+padding)
db_decryption_aes_key – ключ для дешифрования данных из базы данных.
db_decryption_aes_iv - инициализационный вектор для дешифрования данных из базы данных.

### Прием пакета от клиента-отправителя

Принимается информация от клиента-отправителя. Затем сервер, зная sock_id клиента-отправителя, получает его auth_key из базы данных.
Сервер расшифровывает auth_key из базы данных при помощи db_decryption_aes_key и db_decryption_aes_iv.
Сервер получает aes_key и aes_iv, используя auth_key и msg_key клиента- отправителя, расшифровывает encrypted_data и получает decrypted_data.
Далее необходимо зашифровать decrypted_data для отправки клиентам - получателям.
Сервер, зная sock_id клиента-получателя, получает его auth_key из базы данных.
 
Сервер расшифровывает auth_key из базы данных при помощи db_decryption_aes_key и db_decryption_aes_iv.
Сервер получает aes_key и aes_iv, используя auth_key клиента- получателя и msg_key клиента-отправителя, зашифровывает decrypted_data и отправляет клиенту - получателю.
Повтор шагов 2.1-2.3 для всех активных sock_id.

## Модуль client.cpp
### Функция  main

Реализует работу с сокетами.
RSA ключи клиента генерируются заного при запуске программы. В раунде обмена ключами публичный ключ клиента отправляется на сервер.
Инициализация базы данных -создается база данных, содержащая таблицу:

Таблица 2 - Структура базы данных клиента.

| SESSION_ID	 | CHAR(64) | NOT NULL |
|----------------|:---------:|----------------:|
| AUTH_KEY	| CHAR(2048)	| NOT NULL |


При подключении нового клиента создает для него два потока обработки сообщений - приём и отправка.
Отправляет зашифрованное сообщение серверу Структура package идентична структуре package на сервере. 
Ход работы:
- Получение auth_key и session_id из базы данных
- Формирование блока to_be_encrypted (salt+msg+padding)
- Формирование aes_key и aes_iv и шифрование блока to_be_encrypted AES256Encode(to_be_encrypted, aes_key, aes_iv)
- Отправка на сервер

### Функция  getMsg

Принимает зашифрованное сообщение от сервера.

Структура package идентична структуре package на сервере.
 Ход работы:
- Получение auth_key и session_id из базы данных
- Формирование aes_key и aes_iv и дешифрование decrypted_data
- Вывод сообщения в консоль

## Модуль keyExchange.cpp

Генерация auth_key посредством протокола Диффи-Хеллмана.

Функция  getNewSession_client - Обмен ключами, сторона сервера.

Функция  getNewSession_server - Обмен ключами, сторона клиента.

Сервер обменивается с клиентом структурой package Структура package клиента аналогична структуре package сервера:
- session_id - сессионный идентификатор нового клиента
- dh_aes_key – зашифрованный при помощи открытого ключа сервера/клиента AES ключ
- dh_aes_iv - зашифрованный при помощи открытого ключа сервера/клиента AES IV.
- p - 2048 битное число P, генерируется на сервере (см. digits.cpp)
- g - 64 битное число g, генерируется на сервере (см. digits.cpp)
- A – g^amod p для сервера или g^bmod p для клиента Сторона сервера:

Ход работы:
- Генерируется session_id и присваивается новому клиенту. Этот параметр нужен для составления блока tobeencrypted в дальнейшем
- Сервер принимает открытый RSA-ключ клиента
- Сервер генерирует числа p, g, a(64 бит) и высчитывает число A = g^amod p
- Сервер шифрует число A при помощи ключа dh_aes_key и dh_aes_iv, которые шифруются при помоощи открытого ключа клиента. Затем отправляет package клиенту

### Сторона клиента

- Клиент генерирует 64 битное число b и принимает package от сервера. Затем расшифровывает число A при помощи dh_aes_key, dh_aes_iv, которые в свою очередь расшифровываются при помощи закрытого ключа клиента.
- Клиент высчитывает число B = g^bmod p и шифрует его при помощи ключа dh_aes_key и dh_aes_iv, затем отправляет package на сервер. AES параметры шифруются при помощи открытого ключа сервера.
- При помощи А высчитывает auth_key (A^bmod p).

### Сторона сервера

- Сервер принимает package и расшифровывает dh_aes_key, dh_aes_iv при помощи закрытого ключа сервера.
- При помощи dh_aes_key, dh_aes_iv расшифровывает число B и высчитывает auth_key (B^amod p).
- Шифрует auth_key при помощи db_aes_key и db_aes_iv
- Сохраняет в базу данных sock_id, session_id, auth_key


## Модуль msg_encr_decr.cpp
### Функция  getEncryptedBlock

Принимает два параметра: session_id и msg.
Возвращает строку to_be_encrypted длиной 1024 байта.

- to_be_encrypted = salt + session_id + msg + padding, где padding нужен для дополнения  до 1024 байт
- Функция  get_msg_key- возвращает msg_key 
- Функция  get_aes_key - возвращает aes_key 
- Функция  get_aes_iv - возвращает aes_iv msg_key,

### Формулы aes_key, aes_iv, msg_key

aes_key, aes_iv высчитываются по специальным формулам:
- msg_key_large = SHA256 (substr (auth_key, 88+x, 32) + plaintext + random_padding);
- msg_key = substr (msg_key_large, 8, 16);
- sha256_a = SHA256 (msg_key + substr (auth_key, x, 36));
- sha256_b = SHA256 (substr (auth_key, 40+x, 36) + msg_key);
- aes_key = substr (sha256_a, 0, 8) + substr (sha256_b, 8, 16) + substr (sha256_a, 24, 8);
- aes_iv = substr (sha256_b, 0, 8) + substr (sha256_a, 8, 16) + substr (sha256_b, 24, 8);

## Модуль digits.cpp
### Функция  getDigit

Выработка чисел по заданным параметрам:
- digit - сюда записывается результат
- bits - количество битов
- mode - если 1, то вырабатывать простое, если 0, то вырабатывать составное
- base - если 10, вернуть число в DEC, если 16, вернуть число в H
